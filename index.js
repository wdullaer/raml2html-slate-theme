'use strict'
let fs = require('fs')
const path = require('path')
const markdown = require('nunjucks-markdown')
const marked = require('marked')
const Minimize = require('minimize')
const nunjucks = require('nunjucks')
const stylus = require('stylus')

let minimize = new Minimize({quotes: true})
const templatesPath = path.join(__dirname, 'templates')
const DEFAULT_LOGO = path.join(templatesPath, 'images', 'logo.png')
const DEFAULT_COLOR_THEME = path.join(templatesPath, 'css', '_variables.styl.default')
const DEFAULT_LANGUAGE_TABS = '["json"]'

let mdRenderer = new marked.Renderer()
mdRenderer.hr = () => `</div><div class="set-examples">`
mdRenderer.code = (text, language) => `<pre><code class="lang-${language} hljs">${text}</code></pre>`
marked.setOptions({renderer: mdRenderer})

/**
 * Renders a parsed RAML object into the templatesPath
 * @param  {object}          ramlObj A parsed RAML object as produced by raml2obj
 * @param  {object}          config  A map with raml2html configuration
 *                                   (create a typedef for this and validate)
 * @return {Promise<string>}         A Promise resolving to html as a string
 */
function processRamlObj (ramlObj, config) {
  return Promise.all([
    renderCss(templatesPath, config.colorThemePath),
    loadLogo(config.logoPath)
  ])
    .then((data) => {
      ramlObj.css = data[0]
      ramlObj.logo = data[1]
      ramlObj.logoMime = getMimeType(config.logoPath)
      ramlObj.languageTabs = config.languageTabs.length > 1 ? config.languageTabs : undefined
      ramlObj.search = true

      return renderHtml(templatesPath, ramlObj)
    })
}

/**
 * Renders the stylus sheets along with the supplied theme into a css string
 * @param  {string}          basePath       The folder in which stylus references are resolved
 * @param  {string}          colorThemePath The path to _variables.styl
 * @return {Promise<string>}                A Promise resolving to the css stylesheet as a string
 */
function renderCss (basePath, colorThemePath) {
  // TODO: figure out how we can get load this from user config options
  const stylusPath = path.join(basePath, 'css', 'style.styl')
  return Promise.all([readFile(colorThemePath), readFile(stylusPath)])
    .then((stylusFiles) => {
      return new Promise((resolve, reject) => {
        stylus.render(
          stylusFiles.map((item) => item.toString('utf8')).join(''),
          {paths: [path.join(basePath, 'css')]},
          (err, css) => err ? reject(err) : resolve(css)
        )
      })
    })
}

/**
 * Read the logo at logoPath and return the contents as a base64 encoded string
 * @param  {string}          logoPath The path of the logo
 * @return {Promise<string>}          A Promise resolving to the base64 encoded content of the logo
 */
function loadLogo (logoPath) {
  return readFile(logoPath).then((buffer) => buffer.toString('base64'))
}

/**
 * Render the ramlObj into the nunjucks template and return the resulting
 * HTML as a string
 * @param  {string} basePath The directory in which nunjucks references are resolved
 * @param  {object} ramlObj  A ramlObj with some additional properties for logo and css
 * @return {string}          The final HTML
 */
function renderHtml (basePath, ramlObj) {
  const template = path.join(basePath, 'root.nunjucks')
  const env = nunjucks
    .configure(basePath, {autoescape: false})
    .addGlobal('getSafeId', getSafeId)
    .addGlobal('getLanguage', getLanguage)
    .addGlobal('getResponseHeaders', getResponseHeaders)
    .addGlobal('getCurlStatement', getCurlStatement.bind(null, ramlObj.baseUri))
  markdown.register(env, marked)
  return env.render(template, ramlObj)
}

/**
 * Guess the MIME type of a file based on extension. Uses `image/png` by default
 * @param  {string} filePath Path of the filePath
 * @return {string}          The MIME type of the file
 */
function getMimeType (filePath) {
  const pathInfo = path.parse(filePath)
  switch (pathInfo.ext.toLowerCase()) {
    case '.bmp':
      return 'image/bmp'
    case '.svg':
      return 'image/svg+xml'
    case '.tiff':
      return 'image/tiff'
    case '.jpg':
    case '.jpeg':
      return 'image/jpeg'
    case '.gif':
      return 'image/gif'
    case '.png':
    default:
      return 'image/png'
  }
}

/**
 * Promisified version of fs.readFile
 * @param  {string}          path The path of the file to readFile
 * @return {Promise<Buffer>}      A Promise resolving to a buffer with the file content
 */
function readFile (path) {
  return new Promise((resolve, reject) => {
    fs.readFile(path, (err, content) => err ? reject(err) : resolve(content))
  })
}

/**
 * Minimize the HTML
 * @param  {string}          data The HTML generated by the theme
 * @return {Promise<string>}      A Promise resolving to the minimized HTML
 */
function postProcessHtml (data) {
  return new Promise((resolve, reject) => {
    minimize.parse(data, (err, html) => err ? reject(err) : resolve(html))
  })
}

function configureTheme (args) {
  args = args || {}
  if (args['generate-color-theme']) {
    let defaultTheme = fs.readFileSync(DEFAULT_COLOR_THEME, {encoding: 'utf8'})
    fs.writeSync(1, defaultTheme)
    fs.fsyncSync(1)
    process.exit(0)
  }

  const logoPath = args['logo'] || DEFAULT_LOGO
  const colorThemePath = args['color-theme'] || DEFAULT_COLOR_THEME
  const languageTabs = parseLanguageTabs(args['language-tabs'] || DEFAULT_LANGUAGE_TABS)

  return {
    colorThemePath,
    languageTabs,
    logoPath,
    processRamlObj,
    postProcessHtml
  }
}

/**
 * TODO: add tests
 * Convert the `language-tabs` commandline argument into an Array of strings
 * @param  {string} arg        The argument as passed on the commandline
 * @return {array<string>}     An array of strings for the language tabs
 */
function parseLanguageTabs (arg) {
  let languageTabs

  try {
    languageTabs = JSON.parse(arg)
  } catch (e) {
    if (e instanceof SyntaxError) {
      logAndExit()
    } else {
      throw e
    }
  }

  if (!Array.isArray(languageTabs)) {
    logAndExit()
  }

  languageTabs.forEach((item) => {
    if (typeof item !== 'string') {
      logAndExit()
    }
  })

  return languageTabs

  function logAndExit () {
    console.error(`language-tabs argument "${arg}" is invalid`)
    console.error('language-tabs argument should be a JSON array of strings. eg: ["json", "xml"]')
    process.exit(1)
  }
}

/**
 * TODO add tests
 * Ensure a string is safe to use as a html id attribute
 * @param  {string} id The potentially unsafe id string
 * @return {string}    The safe id string
 */
function getSafeId (id) {
  if (id === undefined) id = ''
  return id.toLowerCase().replace(' ', '-')
}

/**
 * TODO add tests
 * Return a short string for use in the language tabs based on the input mime type
 * @param  {string} mime A mime type
 * @return {string}      A short version of the mime type we can use in a css classname
 */
function getLanguage (mime) {
  if (/json/.test(mime)) {
    return 'json'
  } else if (/xml/.test(mime)) {
    return 'xml'
  } else if (mime === 'text/event-stream') {
    return 'sse'
  } else {
    return ''
  }
}

/**
 * TODO add tests
 * Get all unique response headers of a method
 * Only the first instance of a header will be returned
 * @param  {object} method A method object as found in a parsed RAML file
 * @return {array}         An array of header objects
 */
function getResponseHeaders (method) {
  if (!method.responses) return []
  return method.responses
    .map((resp) => resp.headers ? resp.headers : [])
    .reduce((current, resp) => current.concat(resp), [])
    .filter((header, index, array) => array.findIndex((item) => item.key === header.key) === index)
}

/**
 * TODO add tests
 * Generate a cURL statement for a method on a resource
 * @param  {string} baseUri  The baseUri of the API (if any)
 * @param  {object} method   A method object as generated by RAML
 * @param  {object} resource A resource object as generated by RAML
 * @return {string}          A example curl statement that calls the API
 */
function getCurlStatement (baseUri, method, resource) {
  baseUri = baseUri || ''
  if (baseUri.endsWith('/')) baseUri = baseUri.slice(0, -1)

  method.headers = method.headers || []
  let headers = method.headers
    .filter((header) => header.examples && header.examples.length !== 0)
    .map((header) => ` \\\n\t-H "${header.key}: ${header.examples[0].value}"`).join('')

  method.queryParameters = method.queryParameters || []
  let params = method.queryParameters
    .filter((param) => param.examples && param.examples.length !== 0)
    .map((param) => `${param.key}=${param.examples[0].value}`)
    .join('&')
  params = params === '' ? '' : `?${params}`

  let payload = ['patch', 'post', 'put'].includes(method.method) ? ' \\\n\t-d @request_body' : ''

  return `curl -X ${method.method.toUpperCase()} "${baseUri}${resource.parentUrl}${resource.relativeUri}${params}"${headers}${payload}`
}

module.exports = configureTheme
